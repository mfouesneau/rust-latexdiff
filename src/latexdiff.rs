/// A fast Rust implementation of LaTeX diff tools, combining the functionality of `latexdiff` and `latexpand`.
use similar::{ChangeTag, TextDiff};

/// Generate a LaTeX diff between two texts
pub fn generate_diff(old_text: &str, new_text: &str, only_additions: bool, only_deletions: bool) -> String {
    // Preprocess texts to handle LaTeX comments
    let old_processed = preprocess_latex_text(old_text);
    let new_processed = preprocess_latex_text(new_text);
    
    let diff = TextDiff::from_lines(&old_processed, &new_processed);
    let mut result = String::new();
    
    // Add LaTeX preamble for diff commands
    result.push_str("% LaTeX diff generated by rust-latexdiff\n");
    result.push_str("% Add these commands to your preamble:\n");
    result.push_str("% \\usepackage{xcolor}\n");
    result.push_str("% \\newcommand{\\DIFdel}[1]{{\\color{red}\\sout{#1}}}\n");
    result.push_str("% \\newcommand{\\DIFadd}[1]{{\\color{blue}#1}}\n");
    result.push_str("% \\usepackage[normalem]{ulem}\n");
    result.push_str("\n");
    
    for change in diff.iter_all_changes() {
        let line = change.value();
        
        match change.tag() {
            ChangeTag::Equal => {
                result.push_str(line);
            }
            ChangeTag::Delete => {
                if !only_additions {
                    let processed_line = escape_latex_special_chars(line);
                    if is_latex_command_line(&processed_line) {
                        result.push_str(&format!("\\DIFdel{{{}}}", processed_line));
                    } else {
                        result.push_str(&format!("\\DIFdel{{{}}}", processed_line));
                    }
                }
            }
            ChangeTag::Insert => {
                if !only_deletions {
                    let processed_line = escape_latex_special_chars(line);
                    if is_latex_command_line(&processed_line) {
                        result.push_str(&format!("\\DIFadd{{{}}}", processed_line));
                    } else {
                        result.push_str(&format!("\\DIFadd{{{}}}", processed_line));
                    }
                }
            }
        }
    }
    
    result
}

/// Generate a more sophisticated LaTeX diff with better formatting
#[allow(dead_code)]
pub fn generate_advanced_diff(old_text: &str, new_text: &str, only_additions: bool, only_deletions: bool) -> String {
    let mut result = String::new();
    
    // Add comprehensive LaTeX preamble
    result.push_str(LATEX_DIFF_PREAMBLE);
    
    // Preprocess texts to handle LaTeX comments
    let old_processed = preprocess_latex_text(old_text);
    let new_processed = preprocess_latex_text(new_text);
    
    // Split into paragraphs for better diff granularity
    let old_paragraphs = split_into_paragraphs(&old_processed);
    let new_paragraphs = split_into_paragraphs(&new_processed);
    
    let old_joined = old_paragraphs.join("\n\n");
    let new_joined = new_paragraphs.join("\n\n");
    let diff = TextDiff::from_lines(&old_joined, &new_joined);
    
    for change in diff.iter_all_changes() {
        let content = change.value();
        
        match change.tag() {
            ChangeTag::Equal => {
                result.push_str(content);
            }
            ChangeTag::Delete => {
                if !only_additions {
                    result.push_str(&format_deletion(content));
                }
            }
            ChangeTag::Insert => {
                if !only_deletions {
                    result.push_str(&format_addition(content));
                }
            }
        }
    }
    
    result
}

#[allow(dead_code)]
fn split_into_paragraphs(text: &str) -> Vec<String> {
    text.split("\n\n")
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect()
}

#[allow(dead_code)]
fn format_deletion(content: &str) -> String {
    let escaped = escape_latex_special_chars(content);
    
    if is_latex_environment(&escaped) {
        format!("\\DIFdelbegin\n{}\n\\DIFdelend\n", escaped)
    } else if is_latex_command_line(&escaped) {
        format!("\\DIFdel{{{}}}", escaped)
    } else {
        format!("\\DIFdel{{{}}}", escaped)
    }
}

#[allow(dead_code)]
fn format_addition(content: &str) -> String {
    let escaped = escape_latex_special_chars(content);
    
    if is_latex_environment(&escaped) {
        format!("\\DIFaddbegin\n{}\n\\DIFaddend\n", escaped)
    } else if is_latex_command_line(&escaped) {
        format!("\\DIFadd{{{}}}", escaped)
    } else {
        format!("\\DIFadd{{{}}}", escaped)
    }
}

fn escape_latex_special_chars(text: &str) -> String {
    // Don't escape if the text is already LaTeX commands
    if text.trim_start().starts_with('\\') {
        return text.to_string();
    }
    
    // Important: Replace backslash last to avoid double-escaping
    text.replace('&', "\\&")
        .replace('%', "\\%")
        .replace('$', "\\$")
        .replace('#', "\\#")
        .replace('^', "\\textasciicircum{}")
        .replace('_', "\\_")
        .replace('{', "\\{")
        .replace('}', "\\}")
        .replace('~', "\\textasciitilde{}")
}

fn is_latex_command_line(line: &str) -> bool {
    let trimmed = line.trim();
    trimmed.starts_with('\\') || trimmed.contains("\\begin{") || trimmed.contains("\\end{")
}

#[allow(dead_code)]
fn is_latex_environment(text: &str) -> bool {
    text.contains("\\begin{") && text.contains("\\end{")
}

/// Preprocess LaTeX text to handle comments appropriately
/// This function removes or normalizes LaTeX comments before diff processing
fn preprocess_latex_text(text: &str) -> String {
    let lines: Vec<String> = text.lines()
        .enumerate()
        .map(|(i, line)| {
            let context = LaTeXContext::from_previous_lines(&text.lines().take(i).collect::<Vec<_>>());
            remove_latex_comments_with_context(line, &context)
        })
        .filter(|line| !line.trim().is_empty()) // Remove empty lines that were only comments
        .collect();
    
    lines.join("\n")
}

#[derive(Debug, Clone)]
struct LaTeXContext {
    in_verbatim: bool,
}

impl LaTeXContext {
    fn new() -> Self {
        Self {
            in_verbatim: false,
        }
    }
    
    fn from_previous_lines(previous_lines: &[&str]) -> Self {
        let mut context = Self::new();
        
        for line in previous_lines {
            if line.contains("\\begin{verbatim}") {
                context.in_verbatim = true;
            }
            if line.contains("\\end{verbatim}") {
                context.in_verbatim = false;
            }
            // Add more verbatim-like environments as needed
            if line.contains("\\begin{lstlisting}") {
                context.in_verbatim = true;
            }
            if line.contains("\\end{lstlisting}") {
                context.in_verbatim = false;
            }
        }
        
        context
    }
}

/// Remove LaTeX comments from a line with context awareness
/// Handles escaped percent signs (\%) correctly and preserves comments in verbatim environments
fn remove_latex_comments_with_context(line: &str, context: &LaTeXContext) -> String {
    // If we're in a verbatim environment, don't process comments
    if context.in_verbatim {
        return line.to_string();
    }
    
    // Check if this line starts or ends a verbatim environment
    let line_starts_verbatim = line.contains("\\begin{verbatim}") || line.contains("\\begin{lstlisting}");
    let line_ends_verbatim = line.contains("\\end{verbatim}") || line.contains("\\end{lstlisting}");
    
    if line_starts_verbatim && !line_ends_verbatim {
        // This line starts verbatim, preserve everything
        return line.to_string();
    }
    
    remove_latex_comments(line)
}

/// Remove LaTeX comments from a line
/// Handles escaped percent signs (\%) correctly
fn remove_latex_comments(line: &str) -> String {
    let mut result = String::new();
    let mut chars = line.chars().peekable();
    let mut in_verbatim = false;
    
    while let Some(ch) = chars.next() {
        match ch {
            '\\' => {
                // Handle escaped characters
                result.push(ch);
                if let Some(&next_ch) = chars.peek() {
                    if next_ch == '%' || next_ch == '\\' {
                        // Escaped percent or backslash - include both characters
                        result.push(chars.next().unwrap());
                    }
                }
            }
            '%' => {
                // Check if we're in a verbatim environment where % should be preserved
                if in_verbatim {
                    result.push(ch);
                } else {
                    // This is a comment - ignore everything from here to end of line
                    break;
                }
            }
            _ => {
                result.push(ch);
                
                // Simple check for verbatim environments
                // This is a basic implementation - could be enhanced for more complex cases
                if line.contains("\\begin{verbatim}") || line.contains("\\verb") {
                    in_verbatim = true;
                }
                if line.contains("\\end{verbatim}") {
                    in_verbatim = false;
                }
            }
        }
    }
    
    result.trim_end().to_string()
}

const LATEX_DIFF_PREAMBLE: &str = r#"% LaTeX diff generated by rust-latexdiff
% Add these commands to your document preamble:

% Required packages
\usepackage{xcolor}
\usepackage[normalem]{ulem}

% Deletion commands
\newcommand{\DIFdel}[1]{\textcolor{red}{\sout{#1}}}
\newcommand{\DIFdelbegin}{\textcolor{red}{\bgroup\sout\bgroup}}
\newcommand{\DIFdelend}{\egroup\egroup}

% Addition commands  
\newcommand{\DIFadd}[1]{\textcolor{blue}{#1}}
\newcommand{\DIFaddbegin}{\textcolor{blue}{\bgroup}}
\newcommand{\DIFaddend}{\egroup}

% Alternative styles (uncomment to use)
% \newcommand{\DIFdel}[1]{\textcolor{red}{\st{#1}}}
% \newcommand{\DIFadd}[1]{\textcolor{blue}{\bf #1}}

"#;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_diff() {
        let old_text = "Hello world\nThis is a test";
        let new_text = "Hello universe\nThis is a test\nNew line added";
        
        let diff = generate_diff(old_text, new_text, false, false);
        assert!(diff.contains("DIFdel"));
        assert!(diff.contains("DIFadd"));
    }

    #[test]
    fn test_latex_escape() {
        let text = "This has $math$ and {braces} and % comments";
        let escaped = escape_latex_special_chars(text);
        println!("Original: {}", text);
        println!("Escaped: {}", escaped);
        assert!(escaped.contains("\\$"));
        assert!(escaped.contains("\\{"));
        assert!(escaped.contains("\\%"));
    }

    #[test]
    fn test_latex_comment_removal() {
        let text_with_comments = "This is text % this is a comment\nMore text\n% Full line comment\nFinal line";
        let processed = preprocess_latex_text(text_with_comments);
        
        println!("Original:\n{}", text_with_comments);
        println!("Processed:\n{}", processed);
        
        assert!(!processed.contains("this is a comment"));
        assert!(!processed.contains("Full line comment"));
        assert!(processed.contains("This is text"));
        assert!(processed.contains("More text"));
        assert!(processed.contains("Final line"));
    }

    #[test]
    fn test_escaped_percent_preservation() {
        let text = "This has \\% escaped percent and % comment";
        let processed = remove_latex_comments(text);
        
        println!("Original: {}", text);
        println!("Processed: {}", processed);
        
        assert!(processed.contains("\\%"));
        assert!(!processed.contains("comment"));
        assert_eq!(processed, "This has \\% escaped percent and");
    }

    #[test]
    fn test_diff_ignores_comments() {
        let old_text = "Hello world % old comment\nSecond line";
        let new_text = "Hello world % new comment\nSecond line";
        
        let diff = generate_diff(old_text, new_text, false, false);
        
        // Since only comments changed, there should be no DIFdel or DIFadd commands
        // (except in the preamble comments)
        let diff_lines: Vec<&str> = diff.lines().filter(|line| !line.starts_with('%')).collect();
        let content_diff = diff_lines.join("\n");
        
        assert!(!content_diff.contains("DIFdel{"));
        assert!(!content_diff.contains("DIFadd{"));
    }

    #[test]
    fn test_verbatim_comment_preservation() {
        let text = "Normal text % comment\n\\begin{verbatim}\nCode with % symbol\n\\end{verbatim}";
        let processed = preprocess_latex_text(text);
        
        println!("Original:\n{}", text);
        println!("Processed:\n{}", processed);
        
        // Comments in normal text should be removed
        assert!(!processed.contains("comment"));
        // But % in verbatim should be preserved
        assert!(processed.contains("Code with % symbol"));
        assert!(processed.contains("Normal text"));
    }
}
